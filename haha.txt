202020321
大家好，最近抱着玩玩的心态用C++试着实现一些 mathematica 的标准。
这是平时的笔记。

目前只写了个简单的分析器，只支持函数形式的输入，也就是个纯函数式的语言。
实际演示一下吧。

这里符号和 mathematica 一样，不需要声明就可以使用。是个弱类型的。

这是目前支持的函数

先一个个函数演示吧。

在 Set[a, 5] 之后，运算时就会将 a 替换成 5， Set 支持表达式赋值，赋值之前会先计算一遍表达式。
而 SetDelayed 是延时赋值，不会事先计算，直接将表达式赋值给变量。

Plus 支持任意数量，任意类型的参数，代表他们的和。
Times 类似，代表他们的积。

这里因为前面有给a, b 赋值过，所以变成了数字。

Power 还没实现，不过已经可以在目前的基础上编程实现 Power 了，等一下再演示。

Quotient，Mod 是取商和取余，是对整数的运算。要是是算不了的，会保留原样。

Equal 支持两个或以上的参数，若是可以比较的，会返回 True 或 False。若不可以比较，会保持原样。

运算就暂时实现了这些，接下来是函数了。

先是 If 吧，和mma里最基础的三元 If 一样。
注意，这里和 c++ 不同，数字不能代替布尔。

Function 是定义函数（mma 里的也是可以这样）
只支持两个参量的情况：
先给出变量表，用 List 表示，之后给出表达式。

Apply 则是应用函数。具体就是Apply[fun, expr]，代表用 fun 代替 List 语法树的头。

可以搭配 Set/SetDelayed 和 Apply 来实现使用自定义函数的目的。
不用 Apply 直接跟方括号也行。

这里定义了 fun 是接收两个参数的函数，返回 x+y*y*y

自定义函数参数也可以是表达式，这和其他函数是一样的。

忘记将 List 了，代表一个序列，里面可以是任意类型的东西。
用 Flatten 可以展开 List，例如 {{1, 2}, {{3}, 4}} 在 Flatten 之后就是 {1,2,3,4}。

好像没了，然后就是目前可以利用这个做的一些小东西：

这个preSum[n]是求1+2+...n （是大小写敏感的）
可以看到，参数不对，他不会报错，而是保留原样。这样的好处是以后可能修改了定义还能用。

接下来是斐波那契数列
还可以利用递归迭代，来实现列举斐波那契数列。
这里写的 showFib 的算法比较暴力，所以大了以后会算很久。
先中断，换个小点的数吧。
可以赋值多个语句，就是显示的时候有点错位。


接下来是幂运算
这是暴力的做法：
这是快速幂的做法：

这个是把整数每个数字分成一位
刚想到，那类似的，还可以变成进制转换：我改一下
Set[digits, Function[List[n, k],
            If[Equal[n, 0], List[],
                Flatten[List[ digits[Quotient[n, k], k], Mod[n, k] ]]
            ]
        ]]
可以
可以验算一下 666233 的 7 进制是不是 5443241。

接下来是今天最后一个演示了：整数分解：
看看上面的代码吧。
我直接复制过去了，由于这个语言的符号特性，直接写一段话当注释，它也可以过。
因为中文字符有点特殊，所以一股脑复制进去，排版会烂掉，不过不影响内部逻辑。
power 没问题
getm 没问题
这里 g 是用来分隔的，防止 Flatten 的时候把它展开来。
g[a,b] 代表 含有 a^b。其中 a 是质数。
可以看到都是挺正确的。

G好像数字太大了，爆栈了。因为 666233 是个大质数，我用一一枚举的方法，又用的是递归代替循环，所以爆栈了……
看来有必要做一个 For[] 和 While[] 。以后继续更新吧。

再试试一个不是质数的比较大的数

我也还没写大整数类，目前还只是临时用的 int 代替。

以后更新了一些，再更新吧。

再见~
